================================================================================
                    DOCUMENTACI√ìN T√âCNICA - DOOROS
                    Sistema Operativo Simulado
                    Algoritmo: FIFO (First In First Out)
================================================================================

√çNDICE:
1. main.cpp - Programa Principal
2. Sistema_operativo.h/cpp - N√∫cleo del Sistema Operativo
3. bios.h/cpp - Sistema de Inicio
4. config.h/cpp - Configuraci√≥n del Hardware
5. cpu.h/cpp - Unidad Central de Procesamiento
6. PCB.h/cpp - Process Control Block
7. estado.h/cpp - Estados de Procesos
8. memoria_prpal.h/cpp - Memoria Principal (RAM)
9. memoria_sec.h/cpp - Memoria Secundaria
10. marco.h/cpp - Marcos de Memoria
11. ColaSincronizada.h/cpp - Cola Sincronizada de Procesos
12. Reloj.h/cpp - Reloj Global del Sistema
13. dispositivos_IO.h/cpp - Gesti√≥n de Dispositivos E/S
14. DispositivoIO.h/cpp - Dispositivo Individual
15. Estado_IO.h/cpp - Estados de Operaciones E/S
16. Estructuras.h - Estructuras de Datos Globales

================================================================================
1. MAIN.CPP - PROGRAMA PRINCIPAL
================================================================================

PROP√ìSITO:
    Punto de entrada del simulador. Controla el men√∫ interactivo y permite
    crear procesos, cargar desde archivo, ejecutar simulaciones y reiniciar
    el sistema sin cerrar el programa.

COMPONENTES PRINCIPALES:

    void mostrar_menu_principal()
    --------------------------------
    - Muestra el men√∫ con 6 opciones
    - Interfaz de usuario clara y organizada
    
    OPCIONES DEL MEN√ö:
        1. Crear proceso manualmente
        2. Cargar procesos desde archivo
        3. Iniciar simulaci√≥n
        4. Ver estado del sistema
        5. Reiniciar sistema (NUEVO)
        6. Salir

    int main()
    ----------
    - Inicializa BIOS y configuraci√≥n
    - Bucle externo: permite reiniciar el sistema completo
    - Bucle interno: men√∫ de opciones
    - Valida entradas del usuario (evita crashes)
    - Crea nueva instancia del SO en cada reinicio

FLUJO DE EJECUCI√ìN:
    1. BIOS comprueba hardware
    2. BIOS carga sistema operativo
    3. Crear instancia de Sistema_operativo
    4. Mostrar men√∫ y esperar entrada
    5. Ejecutar acci√≥n seleccionada
    6. Si reinicia: volver al paso 3
    7. Si sale: liberar recursos y terminar

VALIDACIONES:
    - Detecta entrada no num√©rica (cin.fail())
    - Limpia buffer autom√°ticamente
    - Previene opciones inv√°lidas

================================================================================
2. SISTEMA_OPERATIVO.H/CPP - N√öCLEO DEL SISTEMA OPERATIVO
================================================================================

PROP√ìSITO:
    Clase central que coordina todos los componentes del sistema operativo.
    Implementa los planificadores, gestiona procesos y ejecuta la simulaci√≥n.

ATRIBUTOS PRIVADOS:
    - Reloj* reloj_global              ‚Üí Tiempo del sistema
    - cpu* unidad_central_proceso      ‚Üí CPU que ejecuta procesos
    - memoria_prpal* gestor_memoria    ‚Üí Memoria RAM (paginaci√≥n)
    - ColaSincronizada* cola_listos    ‚Üí Procesos listos para ejecutar
    - memoria_sec* planificador_largo_plazo ‚Üí Procesos nuevos
    - TlistPCB procesos_terminados     ‚Üí Lista de procesos finalizados
    - dispositivos_IO* dispositivos    ‚Üí Gesti√≥n de E/S
    - int tiempo_simulacion_ms         ‚Üí 100ms por ciclo de CPU

M√âTODOS P√öBLICOS:

    Sistema_operativo(config* conf)
    --------------------------------
    Constructor. Inicializa todos los componentes:
    - Reloj global en 0
    - CPU libre
    - 256 marcos de memoria de 4096 bytes cada uno
    - Cola de listos (capacidad 100)
    - Memoria secundaria
    - Tiempo de simulaci√≥n: 100ms por tick

    void cargar_procesos_desde_archivo(const char* nombre_archivo)
    ---------------------------------------------------------------
    - Lee archivo de texto (formato CSV)
    - Cada l√≠nea: ID, tiempo_llegada, r√°faga, tama√±o
    - Crea PCB para cada proceso
    - Los agrega a memoria secundaria (estado NUEVO)
    - Formato esperado: "P1, 0, 10, 1"

    void crear_proceso_interactivo()
    ---------------------------------
    - Solicita datos al usuario paso a paso
    - VALIDA todas las entradas:
        * ID: m√°ximo 19 caracteres
        * Tiempo de llegada: >= 0
        * R√°faga de CPU: > 0
        * Tama√±o: 1-256 marcos
        * Operaciones E/S: >= 0
        * Dispositivo: DISCO, IMPRESORA o RED
        * Duraci√≥n E/S: > 0
        * Tipo: 0=lectura, 1=escritura
    - Crea PCB y lo agrega a memoria secundaria

    void ejecutar_simulacion()
    ---------------------------
    Bucle principal de la simulaci√≥n (CORAZ√ìN DEL SO):
    
    L√çMITE: 500 ticks (50 segundos reales a 100ms/tick)
    
    CICLO POR CADA TICK:
        1. Gestionar desbloqueos (E/S completadas)
        2. Planificador de largo plazo (NUEVO ‚Üí LISTO)
        3. Ejecutar proceso en CPU o manejar terminaci√≥n
        4. Planificador de corto plazo (LISTO ‚Üí EJECUCI√ìN)
        5. Avanzar reloj global
    
    AL FINALIZAR:
        - Si alcanza l√≠mite: libera procesos incompletos
        - Libera memoria de procesos en CPU
        - Libera memoria de procesos en cola de listos
        - Muestra tabla de memoria final

    void mostrar_estado_sistema()
    ------------------------------
    Muestra informaci√≥n actual:
    - Tick actual del reloj
    - Estado de la CPU (LIBRE/OCUPADA)
    - Procesos en cola de listos (SI/NO)
    - Procesos nuevos pendientes (SI/NO)
    - Marcos de memoria libres

M√âTODOS PRIVADOS:

    bool hay_trabajo_pendiente()
    -----------------------------
    Retorna true si:
    - CPU est√° ocupada, O
    - Hay procesos en cola de listos, O
    - Hay procesos nuevos en memoria secundaria

    void manejar_terminacion(PCB* pcb_terminado)
    --------------------------------------------
    - Cambia estado del PCB a TERMINADO
    - Obtiene ID de memoria del proceso
    - Libera marcos asignados
    - Imprime confirmaci√≥n de liberaci√≥n

    void planificar_largo_plazo()
    ------------------------------
    PLANIFICADOR DE ADMISI√ìN (NUEVO ‚Üí LISTO):
    - Verifica si hay procesos nuevos
    - Verifica si hay memoria disponible
    - Asigna ID num√©rico √∫nico al proceso
    - Guarda ID en el PCB para liberaci√≥n futura
    - Asigna marcos de memoria
    - Cambia estado a LISTO
    - Agrega a cola de listos
    - Elimina de memoria secundaria

    void planificar_corto_plazo()
    ------------------------------
    PLANIFICADOR FIFO (LISTO ‚Üí EJECUCI√ìN):
    - Solo act√∫a si CPU est√° libre
    - Retira primer proceso de cola de listos
    - Lo asigna a la CPU
    - NO hay preempci√≥n (ejecuta hasta terminar)

    void gestionar_desbloqueos()
    ----------------------------
    - Verifica dispositivos de E/S
    - Desbloquea procesos cuya operaci√≥n termin√≥
    - Mueve procesos de BLOQUEADO ‚Üí LISTO

================================================================================
3. BIOS.H/CPP - SISTEMA DE INICIO
================================================================================

PROP√ìSITO:
    Simula el Basic Input/Output System. Verifica hardware y carga el SO.

M√âTODOS:

    void compruebaHard(config &conf)
    --------------------------------
    - Valida configuraci√≥n del hardware
    - Verifica que hay marcos de memoria disponibles
    - Verifica que hay dispositivos configurados
    - Imprime "Hardware check passed"

    void cargaSO(config &conf)
    ---------------------------
    - Simula b√∫squeda del sistema operativo en el MBR
    - Imprime "Searching in MBR SO"
    - Imprime "SO found" si todo est√° OK
    - Carga configuraci√≥n del SO

================================================================================
4. CONFIG.H/CPP - CONFIGURACI√ìN DEL HARDWARE
================================================================================

PROP√ìSITO:
    Almacena la configuraci√≥n de hardware del sistema simulado.

ATRIBUTOS:
    - int cant_total_marcos     ‚Üí Total de marcos de memoria (256)
    - int tam_marco            ‚Üí Tama√±o de cada marco (4096 bytes)
    - int tam_buffer           ‚Üí Tama√±o del buffer compartido
    - int cant_dispositivos    ‚Üí Cantidad de dispositivos E/S

M√âTODOS:

    config()
    --------
    Constructor que lee archivos de configuraci√≥n:
    - configHard.txt: marcos y tama√±o
    - configDisIO.txt: dispositivos E/S

    Getters:
    --------
    - int obt_cant_marcos()
    - int obt_tam_marco()
    - int obt_tam_buffer()
    - int obt_cant_disp()

================================================================================
5. CPU.H/CPP - UNIDAD CENTRAL DE PROCESAMIENTO
================================================================================

PROP√ìSITO:
    Simula la CPU que ejecuta procesos. Mantiene referencia al proceso actual.

ATRIBUTOS:
    - PCB* proceso_actual    ‚Üí Proceso en ejecuci√≥n (NULL si libre)

M√âTODOS:

    bool esta_libre()
    -----------------
    - Retorna true si proceso_actual == NULL
    - Retorna false si hay proceso ejecutando

    void asignar_proceso(PCB* pcb)
    ------------------------------
    - Guarda referencia al proceso
    - Cambia estado del proceso a EJECUCI√ìN
    - Imprime mensaje de asignaci√≥n

    void ejecutar_ciclo(dispositivos_IO* dispositivos)
    --------------------------------------------------
    - Ejecuta 1 ciclo de CPU del proceso actual
    - Decrementa r√°faga restante en 1
    - Imprime r√°faga restante
    - Verifica si proceso solicita E/S
    - Si solicita E/S: bloquea el proceso

    void guardar_y_ceder(PCB* pcb)
    ------------------------------
    - Guarda contexto del proceso (registros)
    - Imprime mensaje de contexto guardado
    - Libera la CPU (proceso_actual = NULL)

    PCB* obtener_proceso_actual()
    -----------------------------
    - Retorna puntero al proceso actual
    - NULL si CPU libre

================================================================================
6. PCB.H/CPP - PROCESS CONTROL BLOCK
================================================================================

PROP√ìSITO:
    Estructura de datos que representa un proceso. Contiene toda la informaci√≥n
    necesaria para gestionar su ejecuci√≥n, memoria y operaciones E/S.

ATRIBUTOS PRIVADOS:
    - char id[MAXID]                     ‚Üí Identificador del proceso
    - estado Estado                      ‚Üí Estado actual (NUEVO, LISTO, etc.)
    - int tiempo_llegada                 ‚Üí Momento de llegada
    - int contador_programa              ‚Üí Instrucci√≥n actual
    - TlistRegistros registros_CPU       ‚Üí Registros guardados
    - int tiempo_rafaga_restante         ‚Üí Ciclos de CPU que faltan
    - int tamanio_requerido              ‚Üí Marcos de memoria necesarios
    - TlistPunMem punteros_memoria       ‚Üí Punteros a marcos asignados
    - TcolaOp operaciones_E_S            ‚Üí Cola de operaciones E/S
    - int tiempo_bloqueo                 ‚Üí Tiempo bloqueado
    - int tiempo_espera_acumulado        ‚Üí Tiempo total esperando
    - int tiempo_finalizacion            ‚Üí Tick de finalizaci√≥n
    - int id_proceso_memoria             ‚Üí ID num√©rico para gesti√≥n de memoria

M√âTODOS P√öBLICOS:

    PCB(char id[], int tiempo_llegada, int rafaga, int tama√±o, TcolaOp ops_es)
    --------------------------------------------------------------------------
    Constructor:
    - Inicializa todos los atributos
    - Estado inicial: NUEVO
    - id_proceso_memoria = -1 (sin asignar)

    void cambio_a_listo(TlistPunMem punteros)
    ------------------------------------------
    - Cambia estado a LISTO
    - Guarda punteros a memoria asignada
    - Imprime transici√≥n de estado

    void cambio_a_ejecucion()
    --------------------------
    - Cambia estado a EJECUCION
    - Imprime transici√≥n

    void cambio_a_bloqueado(int tiempo_fin)
    ----------------------------------------
    - Cambia estado a BLOQUEADO
    - Guarda tiempo de bloqueo
    - Imprime transici√≥n

    void cambio_a_terminado(int tiempo_actual)
    -------------------------------------------
    - Cambia estado a TERMINADO
    - Guarda tiempo de finalizaci√≥n
    - Imprime transici√≥n con timestamp

    void ejecutar_ciclo()
    ---------------------
    - Decrementa tiempo_rafaga_restante en 1
    - Incrementa contador_programa

    int haterminado()
    -----------------
    - Retorna 1 si tiempo_rafaga_restante == 0
    - Retorna 0 en caso contrario

    int obtener_id_proceso_memoria()
    --------------------------------
    - Retorna el ID num√©rico usado para asignar memoria
    - Usado para liberar memoria al terminar

    void asignar_id_proceso_memoria(int id)
    ----------------------------------------
    - Guarda el ID num√©rico de memoria
    - Llamado cuando se asigna memoria al proceso

    Getters:
    --------
    - char* obtener_id()
    - estado obtener_estado()
    - int obtener_rafaga_restante()
    - TlistPunMem obtener_punteros_memoria()
    - int obtener_tiempo_bloqueo()

================================================================================
7. ESTADO.H/CPP - ESTADOS DE PROCESOS
================================================================================

PROP√ìSITO:
    Enumeraci√≥n de los 5 estados posibles de un proceso seg√∫n el modelo de
    5 estados de sistemas operativos.

ENUM estado:
    - NUEVO       ‚Üí Proceso creado, esperando admisi√≥n
    - LISTO       ‚Üí En memoria, esperando CPU
    - EJECUCION   ‚Üí Ejecutando en CPU
    - BLOQUEADO   ‚Üí Esperando operaci√≥n E/S
    - TERMINADO   ‚Üí Ejecuci√≥n completada

TRANSICIONES V√ÅLIDAS:
    NUEVO ‚Üí LISTO           (Planificador largo plazo)
    LISTO ‚Üí EJECUCION       (Planificador corto plazo)
    EJECUCION ‚Üí LISTO       (Quantum agotado - NO APLICA EN FIFO)
    EJECUCION ‚Üí BLOQUEADO   (Solicitud E/S)
    EJECUCION ‚Üí TERMINADO   (R√°faga completada)
    BLOQUEADO ‚Üí LISTO       (E/S completada)

================================================================================
8. MEMORIA_PRPAL.H/CPP - MEMORIA PRINCIPAL (RAM)
================================================================================

PROP√ìSITO:
    Gestiona la memoria RAM usando paginaci√≥n simple. Asigna y libera marcos
    de memoria a los procesos.

ATRIBUTOS:
    - int tamanio_marco           ‚Üí Tama√±o de cada marco (4096 bytes)
    - Tlistmarcos marcos          ‚Üí Lista enlazada de marcos

M√âTODOS:

    memoria_prpal(int cant_marcos, int tam_marco)
    ----------------------------------------------
    Constructor:
    - Crea cant_marcos marcos (256 por defecto)
    - Cada marco tiene tama√±o tam_marco (4096 bytes)
    - Inicialmente todos est√°n libres

    int obtener_marcos_libres()
    ---------------------------
    - Recorre lista de marcos
    - Cuenta cu√°ntos NO est√°n ocupados
    - Retorna cantidad de marcos libres

    TlistPunMem asignar_memoria(int id_proceso, int marcos_requeridos)
    -------------------------------------------------------------------
    - Busca marcos_requeridos marcos libres consecutivos o dispersos
    - Asigna id_proceso a cada marco encontrado
    - Marca marcos como ocupados
    - Retorna lista de punteros a marcos asignados
    - Si no hay suficientes marcos, retorna NULL

    void liberar_memoria(int id_proceso)
    ------------------------------------
    - Recorre TODOS los marcos
    - Busca los que tienen id_proceso asignado
    - Los marca como libres (id = -1)
    - Permite que sean reasignados

    void mostrar_estado_memoria()
    -----------------------------
    - Imprime tabla: "marco  id_proceso_asignado"
    - SOLO muestra marcos ocupados (id != -1)
    - Oculta los 200+ marcos libres para claridad

================================================================================
9. MEMORIA_SEC.H/CPP - MEMORIA SECUNDARIA
================================================================================

PROP√ìSITO:
    Almacena procesos en estado NUEVO que esperan admisi√≥n a memoria principal.
    Funciona como cola de procesos nuevos.

ATRIBUTOS:
    - TlistPCB procesos_nuevos    ‚Üí Lista enlazada de PCBs

M√âTODOS:

    void cargar_proceso(PCB &pcb)
    -----------------------------
    - Agrega proceso al final de la lista
    - Proceso queda en estado NUEVO
    - Espera que planificador LP lo admita

    PCB* obtener_proceso_para_admision()
    -------------------------------------
    - Retorna primer proceso de la lista
    - NO lo elimina (a√∫n)
    - Retorna NULL si lista vac√≠a

    void eliminar_proceso(char* id)
    --------------------------------
    - Busca proceso por ID
    - Lo elimina de la lista
    - Llamado despu√©s de admitir proceso a memoria

    bool hay_procesos_pendientes()
    -------------------------------
    - Retorna true si lista NO est√° vac√≠a
    - Retorna false si no hay procesos

================================================================================
10. MARCO.H/CPP - MARCOS DE MEMORIA
================================================================================

PROP√ìSITO:
    Representa un marco de memoria individual en el esquema de paginaci√≥n.

ATRIBUTOS:
    - int id_proceso_asignado     ‚Üí ID del proceso due√±o (-1 si libre)
    - int tamanio                 ‚Üí Tama√±o del marco (4096 bytes)

M√âTODOS:

    marco(int tam)
    --------------
    Constructor:
    - Inicializa tama√±o
    - id_proceso_asignado = -1 (libre)

    void asignar(int id_proceso)
    ----------------------------
    - Guarda id_proceso
    - Marca marco como ocupado

    void liberar()
    --------------
    - id_proceso_asignado = -1
    - Marca marco como libre

    bool esta_ocupado()
    -------------------
    - Retorna true si id_proceso_asignado != -1
    - Retorna false si marco est√° libre

    int obt_id_proceso_asignado()
    -----------------------------
    - Retorna el ID del proceso asignado
    - Retorna -1 si marco libre

================================================================================
11. COLASINCRONIZADA.H/CPP - COLA SINCRONIZADA DE PROCESOS
================================================================================

PROP√ìSITO:
    Cola thread-safe para procesos LISTOS. Usa sem√°foros para sincronizaci√≥n
    en esquema productor-consumidor.

ATRIBUTOS:
    - buffer_compartido* buffer    ‚Üí Buffer circular interno
    - sem_t sem_vacio             ‚Üí Cuenta espacios vac√≠os
    - sem_t sem_lleno             ‚Üí Cuenta elementos disponibles
    - std::mutex mutex            ‚Üí Exclusi√≥n mutua

M√âTODOS:

    ColaSincronizada(int capacidad)
    --------------------------------
    Constructor:
    - Crea buffer con capacidad especificada
    - Inicializa sem_vacio = capacidad
    - Inicializa sem_lleno = 0
    - Crea mutex

    void Aniadir_a_Cola_Listos(PCB* pcb)
    -------------------------------------
    OPERACI√ìN PRODUCTOR:
    - Espera si cola llena (sem_wait en vacio)
    - Obtiene lock del mutex
    - Agrega PCB al buffer
    - Libera mutex
    - Se√±ala elemento disponible (sem_post en lleno)

    PCB* Retirar_de_Cola_Listos()
    ------------------------------
    OPERACI√ìN CONSUMIDOR:
    - Espera si cola vac√≠a (sem_wait en lleno)
    - Obtiene lock del mutex
    - Retira primer PCB del buffer
    - Libera mutex
    - Se√±ala espacio libre (sem_post en vacio)
    - Retorna PCB

    bool vacia()
    ------------
    - Retorna true si buffer est√° vac√≠o
    - Retorna false en caso contrario

================================================================================
12. RELOJ.H/CPP - RELOJ GLOBAL DEL SISTEMA
================================================================================

PROP√ìSITO:
    Mantiene el tiempo global del sistema en ticks. Cada tick representa
    un ciclo de CPU (100ms de tiempo real).

ATRIBUTOS:
    - int tick_actual    ‚Üí Tiempo actual del sistema

M√âTODOS:

    Reloj()
    -------
    Constructor:
    - tick_actual = 0

    void avanzar_tick()
    -------------------
    - Incrementa tick_actual en 1
    - Llamado al final de cada ciclo de simulaci√≥n

    int obtener_tick()
    ------------------
    - Retorna tick_actual
    - Usado para timestamps en transiciones de estado

================================================================================
13. DISPOSITIVOS_IO.H/CPP - GESTI√ìN DE DISPOSITIVOS E/S
================================================================================

PROP√ìSITO:
    Gestiona m√∫ltiples dispositivos de entrada/salida. Coordina operaciones
    de E/S y maneja colas de procesos bloqueados.

ATRIBUTOS:
    - int cantidad_dispositivos       ‚Üí N√∫mero de dispositivos
    - DispositivoIO** dispositivos    ‚Üí Array de punteros a dispositivos

M√âTODOS:

    dispositivos_IO(int cant)
    -------------------------
    Constructor:
    - Crea cant dispositivos
    - Cada dispositivo tiene ID √∫nico

    void solicitar_IO(char* id_proceso, char* id_dispositivo, int duracion)
    ------------------------------------------------------------------------
    - Busca dispositivo por ID
    - Agrega proceso a cola del dispositivo
    - Proceso queda en estado BLOQUEADO

    char* verificar_y_desbloquear(int tick_actual)
    -----------------------------------------------
    - Recorre todos los dispositivos
    - Verifica si alguna operaci√≥n termin√≥
    - Desbloquea proceso correspondiente
    - Retorna ID del proceso desbloqueado (o NULL)

================================================================================
14. DISPOSITIVOIO.H/CPP - DISPOSITIVO INDIVIDUAL
================================================================================

PROP√ìSITO:
    Representa un dispositivo de E/S espec√≠fico (DISCO, IMPRESORA, RED).
    Maneja cola de procesos esperando usar el dispositivo.

ATRIBUTOS:
    - char id[20]                ‚Üí Identificador (DISCO, IMPRESORA, RED)
    - TcolaPcb cola_bloqueados   ‚Üí Cola de procesos bloqueados
    - bool ocupado               ‚Üí Si est√° procesando operaci√≥n
    - int tiempo_operacion_actual ‚Üí Duraci√≥n de operaci√≥n actual
    - int tick_finalizacion      ‚Üí Cu√°ndo terminar√° operaci√≥n

M√âTODOS:

    DispositivoIO(const char* id_disp)
    -----------------------------------
    Constructor:
    - Guarda ID del dispositivo
    - ocupado = false

    void solicitar_operacion(PCB* pcb, int duracion, int tick_actual)
    ------------------------------------------------------------------
    - Agrega PCB a cola de bloqueados
    - Si dispositivo libre:
        * ocupado = true
        * tiempo_operacion_actual = duracion
        * tick_finalizacion = tick_actual + duracion

    PCB* verificar_finalizacion(int tick_actual)
    ---------------------------------------------
    - Si tick_actual >= tick_finalizacion:
        * Retira proceso de cola
        * ocupado = false
        * Retorna PCB desbloqueado
    - Si no: retorna NULL

================================================================================
15. ESTADO_IO.H/CPP - ESTADOS DE OPERACIONES E/S
================================================================================

PROP√ìSITO:
    Enumeraci√≥n de estados posibles para operaciones de entrada/salida.

ENUM EstadoIO:
    - PENDIENTE    ‚Üí Operaci√≥n en cola, no iniciada
    - EN_PROCESO   ‚Üí Dispositivo procesando la operaci√≥n
    - COMPLETADA   ‚Üí Operaci√≥n finalizada

================================================================================
16. ESTRUCTURAS.H - ESTRUCTURAS DE DATOS GLOBALES
================================================================================

PROP√ìSITO:
    Define todas las estructuras de datos auxiliares usadas en el sistema.

CONSTANTES:
    #define MAXID 20              ‚Üí M√°ximo caracteres para ID de proceso
    #define TAM_MAX_BUFFER 100    ‚Üí Tama√±o m√°ximo del buffer

ESTRUCTURAS PRINCIPALES:

    typedef struct RegistroE_S {
        char id_dispositivo[20];   ‚Üí Dispositivo solicitado
        int duracion;              ‚Üí Ciclos que toma la operaci√≥n
        int tipo_operacion;        ‚Üí 0=lectura, 1=escritura
    } TELEMENTOCOP;

    struct NodoColaOp {
        TELEMENTOCOP dato;
        struct NodoColaOp* sig;
    };

    typedef struct {
        NodoColaOp* frente;
        NodoColaOp* final;
    } TcolaOp;
    ‚Üí Cola enlazada para operaciones E/S de un proceso

    typedef struct Registro {
        int valor;
        struct Registro* sig;
    } Treg;

    typedef Treg* TlistRegistros;
    ‚Üí Lista de registros de CPU

    struct NodoPCB {
        PCB* dato;
        struct NodoPCB* sig;
    };

    typedef NodoPCB* TlistPCB;
    ‚Üí Lista enlazada de PCBs

    typedef struct {
        NodoPCB* primero;
        NodoPCB* ultimo;
    } TcolaPcb;
    ‚Üí Cola de PCBs (usado por dispositivos IO)

    struct NodoMarco {
        marco* contenido;
        struct NodoMarco* sig;
    };

    typedef NodoMarco* Tlistmarcos;
    ‚Üí Lista enlazada de marcos de memoria

    typedef Tlistmarcos TlistPunMem;
    ‚Üí Lista de punteros a memoria asignada a un proceso

FUNCIONES DE GESTI√ìN DE COLAS:

    Para TcolaOp (operaciones E/S):
    -------------------------------
    - void iniciac(TcolaOp &cola)        ‚Üí Inicializa cola vac√≠a
    - void ponec(TcolaOp &cola, TELEMENTOCOP elem)  ‚Üí Encola elemento
    - void sacac(TcolaOp &cola, TELEMENTOCOP &elem) ‚Üí Desencola elemento
    - bool esVaciac(TcolaOp &cola)       ‚Üí Verifica si est√° vac√≠a
    - TELEMENTOCOP consultac(TcolaOp &cola) ‚Üí Consulta frente sin sacar

    Para TcolaPcb (procesos bloqueados):
    ------------------------------------
    - void iniciaPcb(TcolaPcb &cola)     ‚Üí Inicializa cola vac√≠a
    - void ponePcb(TcolaPcb &cola, PCB* proceso) ‚Üí Encola PCB
    - void sacaPcb(TcolaPcb &cola, PCB* &proceso) ‚Üí Desencola PCB
    - bool esVaciaPcb(TcolaPcb &cola)    ‚Üí Verifica si est√° vac√≠a

================================================================================
ALGORITMO FIFO (FIRST IN FIRST OUT)
================================================================================

CARACTER√çSTICAS:
    - Tambi√©n conocido como FCFS (First Come First Served)
    - Algoritmo de planificaci√≥n NO preemptivo
    - El primer proceso que llega es el primero en ejecutarse
    - No hay quantum ni interrupciones
    - Cada proceso ejecuta hasta terminar o pedir E/S

VENTAJAS:
    + Simple de implementar
    + Justo en orden de llegada
    + Sin overhead de cambio de contexto frecuente
    + Predecible

DESVENTAJAS:
    - Efecto convoy: procesos cortos esperan a largos
    - Tiempo de espera promedio puede ser alto
    - No favorece procesos interactivos

IMPLEMENTACI√ìN EN DOOROS:
    1. Cola de listos: FIFO estricto
    2. Planificador CP: asigna solo si CPU libre
    3. Proceso ejecuta hasta:
        - Completar su r√°faga (TERMINADO)
        - Solicitar E/S (BLOQUEADO)
    4. NO hay desalojo por quantum

================================================================================
MODELO DE 5 ESTADOS
================================================================================

DIAGRAMA:
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                        ‚îÇ  NUEVO  ‚îÇ
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ Admisi√≥n (Planif. LP)
                             ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                                                  ‚îÇ
    ‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ  LISTO  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
         E/S       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ           ‚îÇ
       completa         ‚îÇ                 ‚îÇ           ‚îÇ
                        ‚îÇ Dispatch        ‚îÇ           ‚îÇ
                        ‚îÇ (Planif. CP)    ‚îÇ           ‚îÇ
                        ‚Üì                 ‚îÇ           ‚îÇ
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ           ‚îÇ
                   ‚îÇEJECUCION ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   R√°faga              ‚îÇ
                        ‚îÇ         terminada           ‚îÇ
                        ‚îÇ                             ‚îÇ
                        ‚Üì                             ‚îÇ
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                       ‚îÇ
                   ‚îÇBLOQUEADO ‚îÇ                       ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ
                        ‚îÇ E/S                         ‚îÇ
                        ‚îÇ completa                    ‚îÇ
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                      ‚îÇ
                                                      ‚Üì
                                                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                ‚îÇTERMINADO ‚îÇ
                                                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

TRANSICIONES EN DOOROS:

    NUEVO ‚Üí LISTO:
    - Trigger: Planificador largo plazo
    - Condici√≥n: Hay memoria disponible
    - Acci√≥n: Asignar marcos, cambiar estado

    LISTO ‚Üí EJECUCION:
    - Trigger: Planificador corto plazo (FIFO)
    - Condici√≥n: CPU libre
    - Acci√≥n: Asignar proceso a CPU

    EJECUCION ‚Üí BLOQUEADO:
    - Trigger: Proceso solicita E/S
    - Condici√≥n: Operaci√≥n E/S pendiente
    - Acci√≥n: Agregar a cola de dispositivo

    BLOQUEADO ‚Üí LISTO:
    - Trigger: Operaci√≥n E/S completa
    - Condici√≥n: tick >= tick_finalizacion
    - Acci√≥n: Mover a cola de listos

    EJECUCION ‚Üí TERMINADO:
    - Trigger: R√°faga completa
    - Condici√≥n: tiempo_rafaga_restante == 0
    - Acci√≥n: Liberar memoria, liberar CPU

================================================================================
GESTI√ìN DE MEMORIA - PAGINACI√ìN SIMPLE
================================================================================

ESQUEMA:
    - 256 marcos de memoria
    - Cada marco: 4096 bytes
    - Total RAM: 1 MB (1,048,576 bytes)

ASIGNACI√ìN:
    1. Proceso solicita N marcos
    2. Sistema busca N marcos libres
    3. Marcos pueden estar dispersos (no consecutivos)
    4. Se asigna ID num√©rico al proceso
    5. Se marcan marcos como ocupados

LIBERACI√ìN:
    1. Proceso termina
    2. Sistema busca todos los marcos con su ID
    3. Marca cada marco como libre (id = -1)
    4. Marcos disponibles para reasignaci√≥n

TABLA DE P√ÅGINAS:
    - Cada proceso tiene TlistPunMem
    - Lista de punteros a marcos asignados
    - Permite acceso a su memoria

FRAGMENTACI√ìN:
    - Fragmentaci√≥n interna: Desperdicio dentro de marcos
    - Fragmentaci√≥n externa: Minimizada por paginaci√≥n

================================================================================
SINCRONIZACI√ìN - PRODUCTOR-CONSUMIDOR
================================================================================

PROBLEMA:
    - Planificador LP produce procesos listos
    - Planificador CP consume procesos listos
    - Cola compartida debe ser thread-safe

SOLUCI√ìN:

    Sem√°foros:
    ----------
    - sem_vacio: Cuenta espacios libres en cola
    - sem_lleno: Cuenta elementos en cola

    Mutex:
    ------
    - Garantiza exclusi√≥n mutua en acceso a buffer

    Productor (Planificador LP):
    ----------------------------
    1. wait(sem_vacio)    ‚Üí Espera espacio libre
    2. lock(mutex)        ‚Üí Exclusi√≥n mutua
    3. agregar_a_buffer() ‚Üí Operaci√≥n cr√≠tica
    4. unlock(mutex)      ‚Üí Libera acceso
    5. signal(sem_lleno)  ‚Üí Se√±ala elemento disponible

    Consumidor (Planificador CP):
    -----------------------------
    1. wait(sem_lleno)    ‚Üí Espera elemento disponible
    2. lock(mutex)        ‚Üí Exclusi√≥n mutua
    3. retirar_de_buffer()‚Üí Operaci√≥n cr√≠tica
    4. unlock(mutex)      ‚Üí Libera acceso
    5. signal(sem_vacio)  ‚Üí Se√±ala espacio libre

VENTAJAS:
    - Evita condiciones de carrera
    - Previene deadlock
    - Permite concurrencia controlada

================================================================================
VALIDACIONES DE ENTRADA
================================================================================

PROP√ìSITO:
    Prevenir crashes, buffer overflow y comportamiento indefinido por
    entradas inv√°lidas del usuario.

VALIDACIONES IMPLEMENTADAS:

    Men√∫ Principal:
    ---------------
    - Detecta entrada no num√©rica (cin.fail())
    - Limpia buffer autom√°ticamente
    - Rechaza opciones fuera de rango

    Creaci√≥n de Proceso:
    --------------------
    1. Tiempo de llegada:
        - Debe ser >= 0
        - Repite hasta obtener valor v√°lido
        - Manejo de cin.fail()

    2. R√°faga de CPU:
        - Debe ser > 0
        - No se aceptan valores negativos ni cero

    3. Tama√±o de memoria:
        - Rango v√°lido: 1-256 marcos
        - Previene overflow

    4. Cantidad de operaciones E/S:
        - Debe ser >= 0

    5. Dispositivo E/S:
        - Solo acepta: DISCO, IMPRESORA, RED
        - Convierte a may√∫sculas para validar
        - Repite hasta obtener dispositivo v√°lido

    6. Duraci√≥n de E/S:
        - Debe ser > 0

    7. Tipo de operaci√≥n:
        - Solo acepta: 0 (lectura) o 1 (escritura)

T√âCNICAS:
    - do-while loops para repetir solicitud
    - cin.clear() para limpiar flags de error
    - cin.ignore() para limpiar buffer
    - Mensajes claros de error

================================================================================
TEMPORIZACI√ìN REAL
================================================================================

IMPLEMENTACI√ìN:
    #include <thread>
    #include <chrono>

    std::this_thread::sleep_for(std::chrono::milliseconds(100));

CONFIGURACI√ìN:
    - tiempo_simulacion_ms = 100
    - Cada tick = 100ms de tiempo real
    - 10 ticks = 1 segundo real

VISUALIZACI√ìN:
    Tick 0 (0ms)
    Tick 1 (100ms)
    Tick 2 (200ms)
    ...
    Tick 10 (1000ms)

PROP√ìSITO:
    - Simular tiempo real de ejecuci√≥n
    - Permitir observar transiciones de estado
    - Experiencia m√°s realista del SO

DESACTIVACI√ìN:
    Para simulaci√≥n r√°pida, comentar:
    // std::this_thread::sleep_for(...)

================================================================================
FLUJO COMPLETO DE EJECUCI√ìN
================================================================================

FASE 1: INICIALIZACI√ìN
-----------------------
1. main() inicia
2. BIOS comprueba hardware
3. BIOS carga SO
4. Se crea instancia de Sistema_operativo
5. Se inicializan todos los componentes

FASE 2: CARGA DE PROCESOS
--------------------------
Opci√≥n A - Archivo:
    1. Usuario selecciona opci√≥n 2
    2. Ingresa nombre de archivo
    3. Sistema lee archivo l√≠nea por l√≠nea
    4. Crea PCB por cada proceso
    5. Agrega a memoria secundaria (NUEVO)

Opci√≥n B - Manual:
    1. Usuario selecciona opci√≥n 1
    2. Sistema solicita datos paso a paso
    3. Valida cada entrada
    4. Crea PCB con datos validados
    5. Agrega a memoria secundaria (NUEVO)

FASE 3: EJECUCI√ìN DE SIMULACI√ìN
--------------------------------
1. Usuario selecciona opci√≥n 3
2. Sistema inicia bucle principal

   POR CADA TICK (0 a 499):
   
   a) Gestionar desbloqueos:
      - Verificar dispositivos E/S
      - Desbloquear procesos cuya E/S termin√≥
      - Mover de BLOQUEADO ‚Üí LISTO
   
   b) Planificador Largo Plazo:
      - Verificar si hay procesos NUEVOS
      - Verificar si hay memoria disponible
      - Asignar memoria al proceso
      - Guardar ID de memoria en PCB
      - Cambiar estado: NUEVO ‚Üí LISTO
      - Agregar a cola de listos
   
   c) Ejecutar CPU:
      - Si hay proceso en ejecuci√≥n:
          * Si termin√≥: EJECUCION ‚Üí TERMINADO
          * Liberar memoria
          * Liberar CPU
      - Si no termin√≥: ejecutar 1 ciclo
          * Decrementar r√°faga
          * Verificar solicitud E/S
   
   d) Planificador Corto Plazo:
      - Si CPU libre Y hay procesos listos:
          * Retirar primer proceso de cola (FIFO)
          * Asignar a CPU
          * LISTO ‚Üí EJECUCION
   
   e) Avanzar reloj:
      - tick++
      - Pausa de 100ms (tiempo real)
   
   f) Verificar condiciones de salida:
      - ¬øHay trabajo pendiente?
      - ¬øSe alcanz√≥ l√≠mite de 500 ticks?

3. Finalizaci√≥n:
   - Si alcanz√≥ l√≠mite:
       * Liberar proceso en CPU
       * Liberar procesos en cola de listos
       * Mostrar mensaje de l√≠mite alcanzado
   - Mostrar tabla de memoria
   - Mostrar FIN DE SIMULACION

FASE 4: POST-SIMULACI√ìN
------------------------
1. Usuario puede:
   - Ver estado del sistema (opci√≥n 4)
   - Reiniciar sistema (opci√≥n 5)
   - Salir (opci√≥n 6)

2. Si reinicia:
   - Destruye instancia actual de SO
   - Crea nueva instancia
   - Vuelve a FASE 2

3. Si sale:
   - Libera todos los recursos
   - Termina programa

================================================================================
FORMATO DE ARCHIVOS
================================================================================

configHard.txt:
---------------
256 4096

L√≠nea 1: cantidad de marcos
L√≠nea 2: tama√±o de cada marco (bytes)

configDisIO.txt:
----------------
3

L√≠nea 1: cantidad de dispositivos E/S

procesos.txt:
-------------
P1, 0, 10, 1
P2, 2, 8, 1
P3, 4, 6, 1
P4, 6, 12, 1

Formato: ID, tiempo_llegada, rafaga, tama√±o_marcos
- ID: identificador del proceso
- tiempo_llegada: tick de llegada al sistema
- rafaga: ciclos de CPU necesarios
- tama√±o_marcos: marcos de memoria requeridos

================================================================================
ESTAD√çSTICAS Y M√âTRICAS
================================================================================

TIEMPO DE ESPERA:
    - Tiempo que un proceso pasa en cola de LISTO
    - Se acumula en tiempo_espera_acumulado del PCB

TIEMPO DE RETORNO (Turnaround):
    - tiempo_finalizacion - tiempo_llegada
    - Tiempo total desde llegada hasta terminaci√≥n

TIEMPO DE RESPUESTA:
    - Tiempo desde llegada hasta primera ejecuci√≥n

UTILIZACI√ìN DE CPU:
    - Porcentaje de tiempo que CPU estuvo ocupada
    - (Ticks con proceso / Total ticks) * 100

THROUGHPUT:
    - Procesos completados por unidad de tiempo
    - Procesos_terminados / Tiempo_total

================================================================================
LIMITACIONES Y MEJORAS FUTURAS
================================================================================

LIMITACIONES ACTUALES:
    1. Operaciones E/S no se ejecutan realmente
    2. Un solo procesador (no multiprocesador)
    3. Paginaci√≥n simple (no segmentaci√≥n)
    4. No hay memoria virtual (swap)
    5. FIFO puro (no prioridades)
    6. L√≠mite fijo de 500 ticks

MEJORAS POSIBLES:
    1. Implementar m√∫ltiples algoritmos de planificaci√≥n:
        - Round Robin con quantum configurable
        - Prioridades
        - Shortest Job First (SJF)
        - Multilevel Feedback Queue
    
    2. Memoria virtual:
        - Swapping de p√°ginas
        - Algoritmo de reemplazo de p√°ginas (LRU, FIFO)
    
    3. Multiprocesamiento:
        - Varios CPUs
        - Balanceo de carga
    
    4. Estad√≠sticas detalladas:
        - Gr√°ficos de Gantt
        - M√©tricas completas por proceso
        - Exportar resultados a CSV
    
    5. Interfaz gr√°fica:
        - Visualizaci√≥n de estados
        - Animaci√≥n de procesos
        - Gr√°ficos en tiempo real
    
    6. Sistemas de archivos:
        - Simulaci√≥n de disco
        - Directorios y archivos
        - Operaciones de archivo
    
    7. Comunicaci√≥n entre procesos:
        - Pipes
        - Shared memory
        - Message queues

================================================================================
TROUBLESHOOTING - PROBLEMAS COMUNES
================================================================================

1. SIMULACI√ìN NO TERMINA
   S√≠ntoma: Bucle infinito en ejecutar_simulacion()
   Causas:
       - Proceso con r√°faga muy grande
       - L√≠mite de ticks muy bajo
   Soluci√≥n:
       - Aumentar ciclo_limite en sistema_operativo.cpp
       - Verificar valores de r√°faga en procesos.txt

2. MEMORIA NO SE LIBERA
   S√≠ntoma: Marcos quedan ocupados al terminar
   Causas:
       - id_proceso_memoria no se asign√≥
       - liberar_memoria() no se llam√≥
   Soluci√≥n:
       - Verificar asignar_id_proceso_memoria() en planificar_largo_plazo()
       - Verificar manejar_terminacion() llama liberar_memoria()

3. CPU QUEDA OCUPADA
   S√≠ntoma: CPU no se libera al terminar proceso
   Causas:
       - guardar_y_ceder() no se llam√≥
       - proceso_actual no se puso a NULL
   Soluci√≥n:
       - Verificar llamada a guardar_y_ceder() en manejar_terminacion()

4. PROCESOS NO SE CARGAN
   S√≠ntoma: "Procesos nuevos pendientes: NO"
   Causas:
       - Archivo no existe
       - Formato de archivo incorrecto
       - Ruta incorrecta
   Soluci√≥n:
       - Verificar nombre de archivo
       - Verificar formato CSV: "ID, llegada, rafaga, tama√±o"
       - Poner archivo en directorio del ejecutable

5. ERROR DE COMPILACI√ìN
   S√≠ntoma: Errores al compilar
   Causas:
       - Falta incluir headers
       - Incompatibilidad de tipos
       - Funciones no declaradas
   Soluci√≥n:
       - Compilar con: g++ -std=c++17 -Wall -c src/*.cpp main.cpp -Iinclude
       - Verificar todos los .h incluidos
       - Verificar orden de compilaci√≥n

6. VALIDACIONES NO FUNCIONAN
   S√≠ntoma: Acepta valores inv√°lidos
   Causas:
       - cin.fail() no se verifica
       - Buffer no se limpia
   Soluci√≥n:
       - Verificar do-while loops en crear_proceso_interactivo()
       - Verificar cin.clear() y cin.ignore()

================================================================================
REFERENCIAS Y RECURSOS
================================================================================

CONCEPTOS DE SISTEMAS OPERATIVOS:
    - Operating System Concepts (Silberschatz, Galvin, Gagne)
    - Modern Operating Systems (Andrew Tanenbaum)

ALGORITMOS DE PLANIFICACI√ìN:
    - FIFO/FCFS (First Come First Served)
    - Round Robin
    - Priority Scheduling
    - Multilevel Queue

GESTI√ìN DE MEMORIA:
    - Paginaci√≥n
    - Segmentaci√≥n
    - Memoria Virtual
    - TLB (Translation Lookaside Buffer)

SINCRONIZACI√ìN:
    - Sem√°foros (Dijkstra)
    - Mutex y Locks
    - Productor-Consumidor
    - Monitores

EST√ÅNDARES C++:
    - C++17 Standard
    - POSIX Threads
    - C++ Concurrency

================================================================================
AUTORES Y CR√âDITOS
================================================================================

Desarrolladores:
    - Puente Villaroel Gaspar
    - Moar Agust√≠n

Instituci√≥n:
    - [Nombre de la universidad/instituci√≥n]

Materia:
    - Sistemas Operativos

Fecha:
    - Noviembre 2025

Versi√≥n:
    - 2.0 (con FIFO, validaciones, reinicio y liberaci√≥n de memoria)

Licencia:
    - Uso acad√©mico

================================================================================
CHANGELOG - HISTORIAL DE VERSIONES
================================================================================

Versi√≥n 2.0 (Noviembre 2025):
------------------------------
+ Cambio de algoritmo: Round Robin ‚Üí FIFO
+ Men√∫ interactivo con 6 opciones
+ Interfaz de creaci√≥n manual de procesos
+ Validaciones exhaustivas en todas las entradas
+ Temporizaci√≥n real con std::chrono (100ms por tick)
+ Opci√≥n de reiniciar sistema sin cerrar programa
+ Liberaci√≥n correcta de memoria al terminar procesos
+ Campo id_proceso_memoria en PCB para tracking
+ Liberaci√≥n de procesos incompletos si alcanza l√≠mite
+ Dispositivos E/S traducidos al espa√±ol (DISCO/IMPRESORA/RED)
+ Tabla de memoria oculta marcos libres (-1)
+ Comentarios explicativos en todo el c√≥digo
+ Documentaci√≥n completa en espa√±ol
+ L√≠mite aumentado a 500 ticks
+ Mensajes de estado m√°s claros y descriptivos

Versi√≥n 1.0 (Octubre 2025):
---------------------------
+ Implementaci√≥n inicial con Round Robin
+ Modelo de 5 estados
+ Paginaci√≥n simple
+ Sincronizaci√≥n con sem√°foros
+ Cola de listos thread-safe
+ Carga de procesos desde archivo
+ Gesti√≥n b√°sica de E/S

================================================================================
FIN DE LA DOCUMENTACI√ìN
================================================================================

Para m√°s informaci√≥n o reportar problemas:
- Revisar el c√≥digo fuente en los archivos .cpp
- Consultar los headers .h para definiciones
- Ejecutar el programa y probar las opciones del men√∫
- Modificar procesos.txt para diferentes escenarios

¬°Gracias por usar DoorOS! üöÄ
